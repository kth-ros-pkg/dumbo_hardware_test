
#ifndef PI
#define PI 3.141592654
#endif

#define SELECT_LEFT_ARM 	0
#define SELECT_RIGHT_ARM 	1

#define PINV_SVD    1
#define PINV_TRANSPOSE 2

struct angle_struct
{
  	float angle[7];
};

struct pos_struct
{
  float x;
  float y;
  float z;
  float rot[3][3];
  float phi;
  float theta;
  float psi;
};

struct pinv_robotjacob_struct
{
  	float matrix[7][6];
};

struct vel_struct
{
	float tvel[3];
	float avel[3];
};

struct angvel_struct{

	float angvel[7];
};

struct transfmatrix_struct
{
	float transfmatrix[6][6];
};

struct robotjacob_struct 
{
	float matrix[6][7];
};

#ifdef _NOT_DEFINED_

/*Returns the pose struct (pos_struct) (see above) corresponding to the parameters in the input array:
  [x y z phi theta psi]. Where (phi,theta,psi) are the angles of the ZYZ-Euler representation. Angles expressed in radians, distances in meters*/ 
struct pos_struct kinematics_initpose(float pose_params[6]);

/* Forward kinematics for 7 DOF Schunk manipulator; angles expressed in radians in nonrobot coordinates.
Returns rotation matrix + displacement vector. 
An offset of -180 degrees is added to angles 2-7. 
The fwd kinematics are obtained by setting init_frame = 0 , end_frame = 7.
Intermediate transformation matrices can be generated by changing these two parameters.
arm_select = 0 (see #define SELECT_LEFT_ARM) selects the left arm. arm_select = 1 selects the right arm.
DH parameters are expressed as the convention established in intro to robotics book by J.J. Craig. Returns -1 on error.*/
int kinematics_fwdkin(struct pos_struct *ee_position, struct angle_struct arm_angles,int init_frame,int end_frame,int arm_select);

/*Calculates the robot jacobian*/
int kinematics_jacob(struct robotjacob_struct *robotjacob,struct angle_struct arm_angles,int end_frame,int arm_select);

/*Returns (pseudo)-inverse jacobian.
Parameter inverse_method selects the method of inverting the robot jacobian matrix:
1 : (see #define PINV_SVD) returns pseudo inverse calculated by SVD.
2 : (see #define PINV_TRANSPOSE) returns the transpose of the jacobian.
3 : (see #define PINV_DLS) Damped Least Squares. Uses parameter inverse_param.
*/
void kinematics_ijacob(struct pinv_robotjacob_struct *pij,struct robotjacob_struct robotjacob,int inverse_method,float inverse_param);

/*Obtains joint velocities from end effector velocity and arm angles. Multiplies pseudo-inverse jacobian and end effector velocity screw.*/
struct angvel_struct kinematics_endeffvel2jointvel(struct pinv_robotjacob_struct pij,struct vel_struct endeffectorvel);

/*Calibrating raw joint angle/angular velocity  read from the robot to angles/angular velocities as defined by the reference frames established.*/
int kinematics_convertangle_2rawcoord(struct angle_struct *raw_angles,struct angle_struct arm_angles,int arm_select);
int kinematics_convertangle_fromrawcoord(struct angle_struct *arm_angles,struct angle_struct raw_angles,int arm_select);
int kinematics_convertvel_2rawcoord(struct angvel_struct *raw_joint_vel,struct angvel_struct joint_vel,int arm_select);
int kinematics_convertvel_fromrawcoord(struct angvel_struct *arm_vel,struct angvel_struct raw_joint_vel,int arm_select);


/*Functions for converting rotation matrix to/from euler angle parametrization (ZYZ-Euler angle transformation, 
  see 'Robot Modeling and Control' by M. Spong). All angles expressed in radians*/
//Function returns a 3 element array with the phi,theta and psi angles in *pose
void kinematics_euler2rot(struct pos_struct *pose);

//converts rotation matrix in *pose to euler angle parametrization given the euler angles (phi-theta-psi) in the same struct
void kinematics_rot2euler(struct pos_struct *pose);

#endif

/*Printing & debugging*/
void print_velocities(struct vel_struct arm_vel);

void print_joint_vel(struct angvel_struct joint_vel);

void print_pos(struct pos_struct position);

void print_pos_euler(struct pos_struct position);

void print_angles(struct angle_struct arm_angles);
